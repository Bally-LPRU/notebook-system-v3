rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function isAdminUser(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.role == 'admin';
    }
    
    function isApprovedUser() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.status == 'approved';
    }
    
    function hasValidEmail() {
      return isAuthenticated() && 
             (request.auth.token.email.matches('.*@gmail\\.com$') || 
              request.auth.token.email.matches('.*@g\\.lpru\\.ac\\.th$'));
    }
    
    function isInitialUserData(data) {
      return data.keys().hasOnly(['uid', 'email', 'displayName', 'photoURL', 'role', 'status', 'createdAt', 'updatedAt']) &&
             data.uid == request.auth.uid &&
             data.email is string && data.email.size() > 0 &&
             data.role == 'user' &&
             data.status == 'incomplete';
    }
    
    function isValidDepartment(department) {
      return (department is string) ||
             (department is map && 
              department.keys().hasAll(['value', 'label']) &&
              department.value is string &&
              department.label is string && department.label.size() > 0);
    }
    
    function isValidProfileData(data) {
      return true; // Simplified validation for now
    }
    
    function canTransitionStatus(oldStatus, newStatus, isAdminRequest) {
      return isAdminRequest || 
             (oldStatus == newStatus) ||
             (oldStatus == 'incomplete' && newStatus == 'pending');
    }
    
    function isValidUserUpdate(oldData, newData, isAdminRequest) {
      return canTransitionStatus(oldData.status, newData.status, isAdminRequest);
    }

    // Users collection rules
    match /users/{userId} {
      // Allow users to read their own profile and admins to read all
      allow read: if isOwner(userId) || isAdmin();
      
      // Allow authenticated users to query by email for duplicate detection
      allow list: if isAuthenticated() && 
                     request.query.limit <= 1 &&
                     resource.data.email == request.auth.token.email;
      
      allow create: if isOwner(userId) && hasValidEmail() && isInitialUserData(request.resource.data);
      
      allow update: if (isOwner(userId) && hasValidEmail() && 
                       isValidUserUpdate(resource.data, request.resource.data, false) &&
                       request.resource.data.uid == request.auth.uid &&
                       request.resource.data.email == request.auth.token.email) ||
                       (isAdmin() &&
                       // Admins can update as long as immutable fields stay untouched
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid', 'email', 'createdAt']) &&
                       isValidUserUpdate(resource.data, request.resource.data, true));
    }
    
    // Equipment collection rules
    match /equipment/{equipmentId} {
      allow read: if true;
      
      allow create: if isAdmin() && 
                       request.resource.data.keys().hasAll(['name', 'category', 'serialNumber', 'status']) &&
                       request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                       request.resource.data.category is string && request.resource.data.category.size() > 0 &&
                       request.resource.data.serialNumber is string && request.resource.data.serialNumber.size() > 0 &&
                       request.resource.data.status in ['available', 'borrowed', 'maintenance', 'retired'];
      
      allow update: if isAdmin() && 
                       !request.resource.data.keys().hasAny(['createdAt', 'createdBy']);
      
      allow delete: if isAdmin();
    }
    
    // Equipment Management collection rules
    match /equipmentManagement/{equipmentId} {
      // Allow public read for statistics (but not sensitive data)
      allow read: if true;
      
      allow create: if isAdmin() && 
                       request.resource.data.createdBy == request.auth.uid &&
                       request.resource.data.createdAt == request.time;
      
      // Simplified update rule for admin
      allow update: if isAdmin();
      
      allow delete: if isAdmin();
    }
    
    // Equipment Categories collection rules
    match /equipmentCategories/{categoryId} {
      // Allow all authenticated users to read categories (needed for profile setup)
      allow read: if isAuthenticated();
      
      // Allow admin to create categories (flexible createdBy for system seeding)
      allow create: if isAdmin();
      
      // Allow admin to update categories
      allow update: if isAdmin();
      
      allow delete: if isAdmin();
    }
    
    // Loan requests collection rules
    match /loanRequests/{requestId} {
      allow read: if (isApprovedUser() && request.auth.uid == resource.data.userId) || isAdmin();
      
      allow create: if isApprovedUser() && 
                       request.auth.uid == request.resource.data.userId &&
                       request.resource.data.borrowDate is timestamp &&
                       request.resource.data.expectedReturnDate is timestamp &&
                       request.resource.data.borrowDate < request.resource.data.expectedReturnDate;
      
      allow update: if (isApprovedUser() && 
                       request.auth.uid == resource.data.userId &&
                       resource.data.status == 'pending') ||
                       (isAdmin() && 
                       !request.resource.data.keys().hasAny(['userId', 'equipmentId', 'createdAt']));
    }
    
    // Reservations collection rules
    match /reservations/{reservationId} {
      allow read: if true;
      
      allow create: if isApprovedUser() && 
                       request.auth.uid == request.resource.data.userId &&
                       request.resource.data.keys().hasAll(['equipmentId', 'startTime', 'endTime', 'purpose']) &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.startTime is timestamp &&
                       request.resource.data.endTime is timestamp &&
                       request.resource.data.startTime < request.resource.data.endTime &&
                       request.resource.data.startTime > request.time;
      
      allow update: if (isApprovedUser() && 
                       request.auth.uid == resource.data.userId &&
                       resource.data.status == 'pending' &&
                       request.resource.data.keys().hasOnly(['startTime', 'endTime', 'purpose', 'notes', 'updatedAt'])) ||
                       (isAdmin() && 
                       !request.resource.data.keys().hasAny(['userId', 'equipmentId', 'createdAt']));
    }
    
    // Notifications collection rules
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.userId;
      
      // Allow users to mark their own notifications as read
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.userId &&
                       (request.resource.data.isRead == true || resource.data.isRead == true);
      
      // Allow admins to create notifications, or allow authenticated users to create notifications
      // targeted at admins (used for user-submitted loan requests)
      allow create: if isAdmin() ||
                       (isAuthenticated() &&
                        isAdminUser(request.resource.data.userId) &&
                        request.resource.data.userId is string &&
                        request.resource.data.type is string);
      
      // Allow users to delete their own notifications
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Notification settings collection rules
    match /notificationSettings/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // Activity logs collection rules
    match /activityLogs/{logId} {
      allow read: if isAdmin();
      
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
    }
    
    // Equipment audit log collection rules
    match /equipmentAuditLog/{logId} {
      allow read: if isAdmin();
      
      // Allow authenticated users to create audit logs
      allow create: if isAuthenticated();
    }
    
    // User activity log collection rules
    match /userActivityLog/{logId} {
      allow read: if isAdmin() || (isAuthenticated() && request.auth.uid == resource.data.userId);
      
      // Allow authenticated users to create their own activity logs
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
    }
    
    // Equipment history collection rules
    match /equipmentHistory/{historyId} {
      allow read: if isAdmin();
      
      // Allow authenticated users to create history entries
      allow create: if isAuthenticated();
    }
    
    // Scheduled notifications collection rules
    match /scheduledNotifications/{scheduleId} {
      allow read, write: if isAdmin();
    }
    
    // Public statistics collection rules
    match /publicStats/{statsId} {
      allow read: if true;
      
      allow write: if isAdmin();
    }
    
    // Settings collection - admin write, authenticated read
    match /settings/{document} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // Closed dates collection - admin write, authenticated read
    match /closedDates/{dateId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // Category limits collection - admin write, authenticated read
    match /categoryLimits/{categoryId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }
    
    // Settings audit log collection - admin only
    match /settingsAuditLog/{logId} {
      allow read: if isAdmin();
      allow create: if isAdmin(); // Allow admin to create audit logs
      allow update, delete: if false; // Prevent modification/deletion of audit logs
    }
    
    // System notifications collection - admin write, authenticated read
    match /systemNotifications/{notificationId} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
      // Allow users to update their read status and responses
      allow update: if isAuthenticated() && 
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'responses']) &&
                      (request.resource.data.readBy.hasAll(resource.data.readBy) || 
                       request.resource.data.responses.size() >= resource.data.responses.size());
    }
    
    // Saved searches collection - user can read/write their own searches
    match /savedSearches/{searchId} {
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || resource.data.isPublic == true);
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && 
                               resource.data.userId == request.auth.uid;
    }
    
    // Settings backups collection - admin only
    match /settingsBackups/{backupId} {
      allow read, write: if isAdmin();
    }
  }
}
